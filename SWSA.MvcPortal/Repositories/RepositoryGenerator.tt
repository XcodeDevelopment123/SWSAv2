// T4 模板：自动生成 Repository Interface & 实现，并注入 DI（不会覆盖已有代码）
<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".txt" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    string solutionName = "SWSA";
    string nameSpace = $"{solutionName}.MvcPortal";
    string repoInterfaceNameSpace = $"{solutionName}.MvcPortal.Repositories.Interfaces";
    string repoNameSpace = $"{solutionName}.MvcPortal.Repositories.Repo";
    string serviceInterfaceNameSpace = $"{solutionName}.MvcPortal.Services.Interfaces";
    string templateDir = Path.GetDirectoryName(Host.TemplateFile);

    string domainPath = Path.GetFullPath(Path.Combine(templateDir, @"..\Entities"));
    string domainRepositoryPath = Path.GetFullPath(Path.Combine(templateDir, @"Interfaces"));
    string infrastructureRepositoryPath = Path.GetFullPath(Path.Combine(templateDir, @"Repo"));
    string diFilePath = Path.GetFullPath(Path.Combine(templateDir, @"..\Commons\Extensions\DependencyInjector.cs"));
    string diMarker = "//#Repository DI (auto generated)";
    string diMarkerEnd = "//#Repository DI end";

    if (!Directory.Exists(domainRepositoryPath)) Directory.CreateDirectory(domainRepositoryPath);
    if (!Directory.Exists(infrastructureRepositoryPath)) Directory.CreateDirectory(infrastructureRepositoryPath);

    string[] files = new string[0];
    if (!Directory.Exists(domainPath))
    {
#>
// <auto-generated />
// 找不到 Domain\Entities 目录，请检查路径: <#= domainPath #>
<#
    }
    else
    {
        files = Directory.GetFiles(domainPath, "*.cs", SearchOption.TopDirectoryOnly);

        foreach (var file in files)
        {
            string entityName = Path.GetFileNameWithoutExtension(file);
            string interfaceFilePath = Path.Combine(domainRepositoryPath, $"I{entityName}Repository.cs");
            string implementationFilePath = Path.Combine(infrastructureRepositoryPath, $"{entityName}Repository.cs");

            // 创建 Interface
            if (!File.Exists(interfaceFilePath))
            {
                string interfaceCode = $@"using {solutionName}.MvcPortal.Entities;

namespace {repoInterfaceNameSpace};

// <auto-generated />
public interface I{entityName}Repository : IRepositoryBase<{entityName}>
{{
    // Define custom methods if needed
}}";

                File.WriteAllText(interfaceFilePath, interfaceCode, Encoding.UTF8);
            }

            // 创建 Repository 实现
            if (!File.Exists(implementationFilePath))
            {
                string implementationCode = $@"using Microsoft.EntityFrameworkCore;
using {solutionName}.MvcPortal.Entities;
using {solutionName}.MvcPortal.Persistence;
{repoInterfaceNameSpace};

namespace {repoNameSpace};

// <auto-generated />
public class {entityName}Repository(AppDbContext db) : RepositoryBase<{entityName}>(db), I{entityName}Repository
{{
  
    // Implement the method

    //Rewrite the GetAllAsync method
    protected override Task<IQueryable<{entityName}>> BuildQueryAsync()
    {{
       //Default query no action
        return Task.FromResult(db.Set<{entityName}>().AsQueryable());

        // Do you query here
        // var query = db.TableNames.AsNoTracking();
        // return Task.FromResult(query);    
     }}

    //Rewrite the GetWithIncludesAsync method
    protected override Task<IQueryable<{entityName}>> BuildQueryWithIncludesAsync()
    {{
        //Default query no action
        return Task.FromResult(db.Set<{entityName}>().AsQueryable());

        // Do you query here
        // var query = db.TableNames.AsNoTracking();
        // return Task.FromResult(query);    
    }}

     //Rewrite the GetSingleAsync method
    protected override Task<IQueryable<{entityName}>> BuildGetByIdQueryAsync()
    {{
        //Default query no action
        return Task.FromResult(db.Set<{entityName}>().AsQueryable());

        // Do you query here
        // var query = db.TableNames;
        // return Task.FromResult(query);    
    }}

    //Add the method that want to perform before delete the entity
    protected override async Task BeforeRemove({entityName} entity)
    {{
    //Do you logic here
    }}

    //Add the method that want to perform before add the entity
    protected override async Task BeforeAdd({entityName} entity)
    {{
        //Do you logic here
    }}

    //Add the method that want to perform before update the entity
    protected override async Task BeforeUpdate({entityName} entity)
    {{
        //Do you logic here
    }}
}}";

                File.WriteAllText(implementationFilePath, implementationCode, Encoding.UTF8);
            }
        }
    }

     // 注入到 DependencyInjector.cs
    if (!File.Exists(diFilePath))
    {
    #>
    // ⚠️ 找不到 DI 注入文件: <#= diFilePath #>
    <#
    }
    else if (files.Length == 0)
    {
    #>
    // ⚠️ 未找到任何实体类，跳过注入。
    <#
    }
    else
    {
        var diLines = File.ReadAllLines(diFilePath).ToList();
        int startIdx  = diLines.FindIndex(l => l.Contains(diMarker));
        int endIdx = diLines.FindIndex(l => l.Contains(diMarkerEnd));
        if (startIdx  < 0 || endIdx <= startIdx)
        {
    #>
    // ⚠️ 找不到注入标记 "//#Repository DI"，请手动添加到: <#= diFilePath #>
    <#
        }
        else
        {
                // 收集当前已有注入行
        var existingLines = diLines
            .Skip(startIdx + 1)
            .Take(endIdx - startIdx - 1)
            .Where(l => l.Trim().StartsWith("services.AddScoped"))
            .ToList();

        // 构造所有应注入的行
        var newInjectLines = new List<string>();
        foreach (var file in files)
        {
            string entityName = Path.GetFileNameWithoutExtension(file);
            string interfaceName = $"I{entityName}Repository";
            string className = $"{entityName}Repository";
            string injectLine = $"        services.AddScoped<{interfaceName}, {className}>();";

            if (!existingLines.Any(l => l.Contains(interfaceName) && l.Contains(className)))
            {
                newInjectLines.Add(injectLine);
            }
        }

        // 合并、排序、去重
        var mergedLines = existingLines
            .Concat(newInjectLines)
            .Distinct()
            .OrderBy(l => l)
            .ToList();

        // 替换原内容
        diLines.RemoveRange(startIdx + 1, endIdx - startIdx - 1);
        diLines.InsertRange(startIdx + 1, mergedLines);

        // 写回
        File.WriteAllLines(diFilePath, diLines);
        #>
        // ✅ 注入完成，共添加 <#= newInjectLines.Count #> 项 Repository 注册
        <#
        }
    }

#>